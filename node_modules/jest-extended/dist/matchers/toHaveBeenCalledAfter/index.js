"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHaveBeenCalledAfter = toHaveBeenCalledAfter;

var _jestMatcherUtils = require("jest-matcher-utils");

var _utils = require("../../utils");

var _predicate = _interopRequireDefault(require("./predicate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const passMessage = (firstInvocationCallOrder, secondInvocationCallOrder) => () => (0, _jestMatcherUtils.matcherHint)('.not.toHaveBeenCalledAfter') + '\n\n' + 'Expected first mock to not have been called after, invocationCallOrder:\n' + `  ${(0, _jestMatcherUtils.printExpected)(firstInvocationCallOrder)}\n` + 'Received second mock with invocationCallOrder:\n' + `  ${(0, _jestMatcherUtils.printReceived)(secondInvocationCallOrder)}`;

const failMessage = (firstInvocationCallOrder, secondInvocationCallOrder) => () => (0, _jestMatcherUtils.matcherHint)('.toHaveBeenCalledAfter') + '\n\n' + 'Expected first mock to have been called after, invocationCallOrder:\n' + `  ${(0, _jestMatcherUtils.printExpected)(firstInvocationCallOrder)}\n` + 'Received second mock with invocationCallOrder:\n' + `  ${(0, _jestMatcherUtils.printReceived)(secondInvocationCallOrder)}`;

const mockCheckFailMessage = (value, isReceivedValue) => () => {
  const valueKind = isReceivedValue ? 'Received' : 'Expected';
  const valueKindPrintFunc = isReceivedValue ? _jestMatcherUtils.printReceived : _jestMatcherUtils.printExpected;
  return (0, _jestMatcherUtils.matcherHint)('.toHaveBeenCalledAfter') + '\n\n' + `Matcher error: ${valueKindPrintFunc(valueKind.toLowerCase())} must be a mock or spy function` + '\n\n' + (0, _jestMatcherUtils.printWithType)(valueKind, value, valueKindPrintFunc);
};

function toHaveBeenCalledAfter(firstMock, secondMock) {
  if (!(0, _utils.isJestMockOrSpy)(firstMock)) {
    return {
      pass: false,
      message: mockCheckFailMessage(firstMock, true)
    };
  }

  if (!(0, _utils.isJestMockOrSpy)(secondMock)) {
    return {
      pass: false,
      message: mockCheckFailMessage(secondMock, false)
    };
  }

  const firstInvocationCallOrder = firstMock.mock.invocationCallOrder;
  const secondInvocationCallOrder = secondMock.mock.invocationCallOrder;
  const pass = (0, _predicate.default)(firstInvocationCallOrder, secondInvocationCallOrder);

  if (pass) {
    return {
      pass: true,
      message: passMessage(firstInvocationCallOrder, secondInvocationCallOrder)
    };
  }

  return {
    pass: false,
    message: failMessage(firstInvocationCallOrder, secondInvocationCallOrder)
  };
}