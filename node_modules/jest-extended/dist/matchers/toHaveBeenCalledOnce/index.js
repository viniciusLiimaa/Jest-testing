"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHaveBeenCalledOnce = toHaveBeenCalledOnce;

var _jestMatcherUtils = require("jest-matcher-utils");

var _utils = require("../../utils");

var _predicate = _interopRequireDefault(require("./predicate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const passMessage = () => () => (0, _jestMatcherUtils.matcherHint)('.not.toHaveBeenCalledOnce') + '\n\n' + 'Expected mock function to have been called any amount of times but one, but it was called exactly once.';

const failMessage = mockFn => () => {
  return (0, _jestMatcherUtils.matcherHint)('.toHaveBeenCalledOnce') + '\n\n' + 'Expected mock function to have been called exactly once, but it was called:\n' + `  ${(0, _jestMatcherUtils.printReceived)(mockFn.mock.calls.length)} times`;
};

const mockCheckFailMessage = value => () => {
  return (0, _jestMatcherUtils.matcherHint)('.toHaveBeenCalledAfter') + '\n\n' + `Matcher error: ${(0, _jestMatcherUtils.printReceived)('received')} must be a mock or spy function` + '\n\n' + (0, _jestMatcherUtils.printWithType)('Received', value, _jestMatcherUtils.printReceived);
};

function toHaveBeenCalledOnce(received) {
  if (!(0, _utils.isJestMockOrSpy)(received)) {
    return {
      pass: false,
      message: mockCheckFailMessage(received)
    };
  }

  const pass = (0, _predicate.default)(received);
  return {
    pass,
    message: pass ? passMessage(received) : failMessage(received),
    actual: received
  };
}